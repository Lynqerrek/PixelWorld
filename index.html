<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Pixel Worlds — Seeded Menu, Islands & Water</title>
  <style>
    :root {
      --accent1: #ffd36b;
      --accent2: #ffae6b;
      --panel: rgba(3,10,21,0.72);
      --muted: #9fb7cc;
      --glass: rgba(255,255,255,0.035);
    }
    html,body{height:100%;margin:0;background:#061022;color:#e6f0fb;font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,Arial}
    canvas{display:block; image-rendering: pixelated; width:100vw; height:100vh;}
    .hud{position:fixed;left:12px;top:12px;z-index:30;background:var(--panel);padding:10px;border-radius:8px;font-size:13px}
    .hint{position:fixed;right:12px;bottom:12px;background:var(--panel);padding:8px;border-radius:8px;font-size:13px}
    a{color:#9fe0ff}

    /* Menu (Pixel Worlds-ish) */
    #menu {
      position:fixed; inset:0; display:flex; align-items:center; justify-content:center; z-index:60;
      background: linear-gradient(180deg, rgba(2,6,12,0.55), rgba(2,6,12,0.8));
      backdrop-filter: blur(4px);
    }
    #menuCard {
      width:680px; max-width:94%; background:linear-gradient(180deg,#061227,#08192e); border-radius:14px; padding:22px;
      box-shadow: 0 12px 40px rgba(0,0,0,0.66); color:#eaf6ff; font-family: Inter, system-ui, sans-serif;
      display:grid; grid-template-columns: 1fr 220px; gap:16px; align-items:start;
    }
    #menuLeft h1{ margin:0 0 6px 0; font-size:24px }
    .muted{ color:var(--muted); font-size:13px; margin-top:6px }
    .row{ display:flex; gap:8px; align-items:center; margin-top:12px }
    input[type="text"]{ flex:1; padding:10px 12px; border-radius:8px; border:1px solid rgba(255,255,255,0.06); background:var(--glass); color:#eaf6ff; font-family:monospace }
    .btn { padding:12px 14px; border-radius:10px; background:linear-gradient(180deg,var(--accent1),var(--accent2)); border:none; cursor:pointer; font-weight:700; color:#112; box-shadow:0 6px 18px rgba(0,0,0,0.45) }
    .btn.ghost { background:transparent; border:1px solid rgba(255,255,255,0.06); color:#eaf6ff; font-weight:600; box-shadow:none }
    label.small{ font-size:12px; color:var(--muted); margin-right:6px }
    input[type="range"]{ width:100% }
    select{ padding:8px 10px; border-radius:8px; background:var(--glass); border:1px solid rgba(255,255,255,0.04); color:#eaf6ff }

    #preview { background:linear-gradient(180deg,#071627,#05202b); border-radius:8px; padding:8px; display:flex; flex-direction:column; gap:8px; align-items:center; }
    #miniCanvas{ width:200px; height:120px; background:#02131a; display:block; border-radius:6px; image-rendering: pixelated; }
    .metaRow{ display:flex; gap:8px; width:100%; justify-content:space-between; font-size:13px; color:var(--muted) }

    /* loading overlay */
    #loadingOverlay { position:fixed; left:0; top:0; right:0; bottom:0; display:none; align-items:center; justify-content:center; z-index:80;
      background: linear-gradient(180deg, rgba(3,6,12,0.78), rgba(3,6,12,0.84));
    }
    #loadingCard { width:480px; max-width:90%; padding:18px; border-radius:10px; text-align:center; background:linear-gradient(180deg,#05111c,#071826); color:#fff }
    #loaderBar { width:100%; height:12px; background:rgba(255,255,255,0.05); border-radius:8px; overflow:hidden }
    #loaderFill { height:100%; width:0%; background:linear-gradient(90deg,var(--accent1),var(--accent2)); }

    /* small form helpers */
    .mutefloat { font-size:12px; color:var(--muted) }

    /* responsive */
    @media (max-width:720px){
      #menuCard { grid-template-columns: 1fr; padding:16px }
      #miniCanvas { width:100%; height:120px }
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>

  <div class="hud" id="hud">Ready</div>
  <div class="hint">Controls: ←/A →/D • Space/W/↑ to jump • Mousewheel to zoom • Double-click to reset zoom</div>

  <!-- Menu -->
  <div id="menu" role="dialog" aria-modal="true">
    <div id="menuCard">
      <div id="menuLeft">
        <h1>Pixel Worlds — Create World</h1>
        <div class="muted">Choose a seed, world type, and size. Preview updates in real time.</div>

        <div class="row" style="margin-top:14px">
          <input id="seedInput" type="text" placeholder="Enter seed (e.g. MyIsland42)">
          <button class="btn" id="randomBtn">RANDOM</button>
        </div>

        <div class="row">
          <label class="small">World type</label>
          <select id="worldType">
            <option value="islands">Islands (many small islands & water)</option>
            <option value="mainland">Mainland (continuous land, mountains & one lake)</option>
          </select>
          <div style="flex:1"></div>
        </div>

        <div class="row" style="margin-top:6px">
          <div style="flex:1">
            <label class="small muted">Width: <span id="widthVal">300</span></label>
            <input id="widthRange" type="range" min="120" max="700" value="300">
          </div>
          <div style="width:120px">
            <label class="small muted">Height: <span id="heightVal">40</span></label>
            <input id="heightRange" type="range" min="24" max="80" value="40">
          </div>
        </div>

        <div class="row" style="margin-top:10px">
          <label class="small">Start zoom</label>
          <select id="startZoom">
            <option value="1">1x</option>
            <option value="1.5">1.5x</option>
            <option value="2" selected>2x</option>
          </select>
          <div style="flex:1"></div>
        </div>

        <div class="row" style="margin-top:14px;">
          <button class="btn" id="playBtn" style="flex:1; font-size:16px;">PLAY</button>
          <button class="btn ghost" id="regenBtn">PREVIEW</button>
        </div>

        <div class="mutefloat" style="margin-top:10px">Seed hex: <span id="seedHex" style="font-family:monospace"></span></div>
      </div>

      <div id="preview">
        <canvas id="miniCanvas" width="200" height="120"></canvas>
        <div class="metaRow"><div id="modeLabel">Mode: —</div><div id="sizeLabel">Size: —</div></div>
        <div style="width:100%; display:flex; gap:8px;">
          <button class="btn ghost" id="copySeed">Copy seed</button>
          <div style="flex:1"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- loading overlay -->
  <div id="loadingOverlay"><div id="loadingCard">
    <div style="font-size:20px; font-weight:700; margin-bottom:6px">Generating world…</div>
    <div style="font-size:13px; margin-bottom:12px; color:#dbeefc">Preparing terrain & features</div>
    <div id="loaderBar"><div id="loaderFill"></div></div>
    <div style="margin-top:8px; font-size:12px; color:#bfe0ff" id="loaderText">0%</div>
  </div></div>

<script>
/* Full single-file demo:
 - Seeded generator: mulberry32 + fnv1a
 - Two world types: islands & mainland
 - Offscreen tile canvas to reduce per-frame tile draw work
 - Water tiles with wave animation + reflection
 - Improved sun & sky
 - Menu with mini-preview
 - Performance improvements and safe caps
*/

(() => {
  // DOM
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const hud = document.getElementById('hud');
  const menu = document.getElementById('menu');
  const seedInput = document.getElementById('seedInput');
  const randomBtn = document.getElementById('randomBtn');
  const widthRange = document.getElementById('widthRange');
  const heightRange = document.getElementById('heightRange');
  const widthVal = document.getElementById('widthVal');
  const heightVal = document.getElementById('heightVal');
  const playBtn = document.getElementById('playBtn');
  const regenBtn = document.getElementById('regenBtn');
  const worldTypeSel = document.getElementById('worldType');
  const startZoomSel = document.getElementById('startZoom');
  const seedHex = document.getElementById('seedHex');
  const miniCanvas = document.getElementById('miniCanvas');
  const miniCtx = miniCanvas.getContext('2d');
  const modeLabel = document.getElementById('modeLabel');
  const sizeLabel = document.getElementById('sizeLabel');
  const copySeed = document.getElementById('copySeed');
  const loadingOverlay = document.getElementById('loadingOverlay');
  const loaderFill = document.getElementById('loaderFill');
  const loaderText = document.getElementById('loaderText');

  function resize(){ canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
  window.addEventListener('resize', resize); resize();

  // tile and world params
  const TILE = 32;
  let WORLD_W = 300;
  let WORLD_H = 40;

  // offscreen tile canvas (will be reallocated per generation)
  let tileCanvas = document.createElement('canvas');
  let tileCtx = tileCanvas.getContext('2d');

  // data containers
  let tiles = new Uint8Array(0); // 0 empty, 1 ground, 2 water
  let heightMap = [];
  let particles = [];
  let clouds = [];
  let waterOffset = 0;

  // player + physics
  const player = { x: TILE*5 + TILE/2, y: TILE*10, w:22, h:28, vx:0, vy:0, onGround:false, facing:1 };
  const GRAVITY=1400, MAX_FALL=1400, MAX_SPEED=220, GROUND_ACCEL=14000, AIR_ACCEL=3200, JUMP_SPEED=520, JUMP_CUTOFF=200, COYOTE_TIME=0.10, JUMP_BUFFER=0.10;
  let coyoteTimer=0, jumpBufferTimer=0;

  // input
  const input = {left:false,right:false,jump:false,jumpHeld:false};
  window.addEventListener('keydown', e=>{
    if(e.code==='ArrowLeft'||e.code==='KeyA') input.left=true;
    if(e.code==='ArrowRight'||e.code==='KeyD') input.right=true;
    if(e.code==='ArrowUp'||e.code==='KeyW'||e.code==='Space'){
      if(!input.jump){ input.jump=true; input.jumpHeld=true; jumpBufferTimer = JUMP_BUFFER; }
    }
  });
  window.addEventListener('keyup', e=>{
    if(e.code==='ArrowLeft'||e.code==='KeyA') input.left=false;
    if(e.code==='ArrowRight'||e.code==='KeyD') input.right=false;
    if(e.code==='ArrowUp'||e.code==='KeyW'||e.code==='Space'){ input.jumpHeld=false; input.jump=false; }
  });

  // improved RNG (fnv1a -> mulberry32)
  function xfnv1a(str){
    let h = 2166136261 >>> 0;
    for(let i=0;i<str.length;i++){ h ^= str.charCodeAt(i); h = Math.imul(h,16777619); }
    return h >>> 0;
  }
  function mulberry32(seed){
    return function(){
      seed |= 0; seed = seed + 0x6D2B79F5 | 0;
      let t = Math.imul(seed ^ seed >>> 15, 1 | seed);
      t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
      return ((t ^ t >>> 14) >>> 0) / 4294967296;
    };
  }

  // tile helpers
  function idx(tx,ty){ return ty*WORLD_W + tx; }
  function tileAt(tx,ty){ if(tx<0||tx>=WORLD_W||ty<0||ty>=WORLD_H) return 1; return tiles[idx(tx,ty)]; }
  function worldToTile(px){ return Math.floor(px / TILE); }

  // collision
  function resolveCollision(px,py,w,h,vx,vy,dt){
    let nx=px, ny=py, nvx=vx, nvy=vy;
    nx += nvx*dt; let left=worldToTile(nx-w/2), right=worldToTile(nx+w/2-0.0001), top=worldToTile(ny-h/2), bottom=worldToTile(ny+h/2-0.0001);
    for(let ty=top;ty<=bottom;ty++){
      if(tileAt(left,ty)===1){ nx = (left+1)*TILE + w/2 + 0.001; nvx=0; left=worldToTile(nx-w/2); }
      if(tileAt(right,ty)===1){ nx = (right)*TILE - w/2 - 0.001; nvx=0; right=worldToTile(nx+w/2-0.0001); }
    }
    ny += nvy*dt; left = worldToTile(nx-w/2); right = worldToTile(nx+w/2-0.0001); top = worldToTile(ny-h/2); bottom = worldToTile(ny+h/2-0.0001);
    let onGround=false;
    for(let tx=left;tx<=right;tx++){
      if(tileAt(tx,top)===1){ ny = (top+1)*TILE + h/2 + 0.001; nvy=0; top=worldToTile(ny-h/2); }
      if(tileAt(tx,bottom)===1){ ny = (bottom)*TILE - h/2 - 0.001; nvy=0; bottom=worldToTile(ny+h/2-0.0001); onGround=true; }
    }
    return {x:nx,y:ny,vx:nvx,vy:nvy,onGround};
  }

  // camera and zoom limits (reduced zoom-out)
  const camera = { x:0, y:0, scale:2, targetScale:2 };
  const allowedScales = [0.8,1,1.5,2,3]; // min scale 0.8 (not extremely zoomed-out)
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
  let lastMouse = {x:window.innerWidth/2, y:window.innerHeight/2};
  window.addEventListener('mousemove', e => { lastMouse.x = e.clientX; lastMouse.y = e.clientY; });
  function scheduleSnap(){
    if(this._snapT) clearTimeout(this._snapT);
    this._snapT = setTimeout(()=>{
      let nearest = allowedScales[0], bestd = Math.abs(camera.targetScale - nearest);
      for(const s of allowedScales){ const d = Math.abs(camera.targetScale - s); if(d < bestd){ bestd = d; nearest = s; } }
      const rect = canvas.getBoundingClientRect(); const mx = lastMouse.x - rect.left, my = lastMouse.y - rect.top;
      const worldBeforeX = camera.x + mx / camera.targetScale, worldBeforeY = camera.y + my / camera.targetScale;
      camera.targetScale = nearest;
      const worldAfterX = camera.x + mx / camera.targetScale, worldAfterY = camera.y + my / camera.targetScale;
      camera.x += (worldAfterX - worldBeforeX); camera.y += (worldAfterY - worldBeforeY);
      this._snapT = null;
    }, 160);
  }
  window.addEventListener('wheel', (e)=>{
    const zoomFactor = Math.pow(1.0018, -e.deltaY); let newTarget = clamp(camera.targetScale * zoomFactor, allowedScales[0], allowedScales[allowedScales.length-1]);
    const rect = canvas.getBoundingClientRect(), sx = e.clientX - rect.left, sy = e.clientY - rect.top;
    const worldBeforeX = camera.x + sx / camera.targetScale, worldBeforeY = camera.y + sy / camera.targetScale;
    camera.targetScale = newTarget;
    const worldAfterX = camera.x + sx / camera.targetScale, worldAfterY = camera.y + sy / camera.targetScale;
    camera.x += (worldAfterX - worldBeforeX); camera.y += (worldAfterY - worldBeforeY);
    scheduleSnap();
  }, {passive:true});
  canvas.addEventListener('dblclick', ()=>{ camera.targetScale = 2; });

  // clouds
  function makeClouds(rng){
    clouds = [];
    const count = Math.max(8, Math.floor(WORLD_W/18));
    for(let i=0;i<count;i++){
      clouds.push({
        x: rng()*WORLD_W*TILE,
        y: 40 + rng()*180,
        scale: 0.6 + rng()*1.4,
        speed: 6 + rng()*28,
        alpha: 0.4 + rng()*0.5
      });
    }
  }

  // particles (cheap)
  function spawnFootParticles(){
    const footX = player.x + (player.facing===1 ? player.w*0.18 : -player.w*0.18); const footY = player.y + player.h/2 - 4;
    const count = Math.random() < 0.6 ? 1 : 2;
    for(let i=0;i<count;i++){
      if(particles.length > 220) particles.shift();
      particles.push({ x:footX + (Math.random()-0.5)*8, y:footY + (Math.random()-0.5)*4, vx:(Math.random()-0.5)*60 + player.vx*0.12, vy:-Math.random()*90 - 10, life:0.36 + Math.random()*0.22, age:0, size:1 + Math.random()*2 });
    }
  }

  // move helper
  function moveToward(v,target,maxDelta){ if(v<target) return Math.min(v+maxDelta,target); if(v>target) return Math.max(v-maxDelta,target); return v; }

  // sky & sun (improved)
  function lerp(a,b,t){ return a + (b-a)*t; }
  function lerpColor(c1,c2,t){ return `rgb(${Math.round(lerp(c1[0],c2[0],t))},${Math.round(lerp(c1[1],c2[1],t))},${Math.round(lerp(c1[2],c2[2],t))})`; }

  function drawSky(){
    // t is world-wide normalized x
    const t = clamp(player.x / (WORLD_W*TILE), 0, 1);
    // color stops morning -> noon -> dusk
    const topColor = t < 0.45 ? lerpColor([125,200,255],[95,170,255], t/0.45) : lerpColor([95,170,255],[20,40,90], (t-0.45)/0.55);
    const bottomColor = t < 0.45 ? lerpColor([210,235,255],[150,215,255], t/0.45) : lerpColor([150,215,255],[60,90,140], (t-0.45)/0.55);
    const g = ctx.createLinearGradient(0,0,0,canvas.height);
    g.addColorStop(0, topColor); g.addColorStop(1, bottomColor);
    ctx.fillStyle = g; ctx.fillRect(0,0,canvas.width,canvas.height);

    // sun follows a smooth arc
    const sunT = t;
    const sunX = Math.round((sunT*1.2 - 0.1)*canvas.width);
    const sunArc = Math.sin(sunT*Math.PI);
    const sunY = Math.round(canvas.height*0.18 - sunArc*(canvas.height*0.13));
    const sunR = 34 + sunArc*18;
    // halo
    const sg = ctx.createRadialGradient(sunX, sunY, 0, sunX, sunY, sunR*3.2);
    sg.addColorStop(0, 'rgba(255,245,210,0.98)'); sg.addColorStop(0.16, 'rgba(255,230,150,0.36)'); sg.addColorStop(1, 'rgba(255,200,120,0)');
    ctx.fillStyle = sg; ctx.beginPath(); ctx.arc(sunX,sunY,sunR*3.2,0,Math.PI*2); ctx.fill();
    // core
    ctx.fillStyle = 'rgba(255,248,210,1)'; ctx.beginPath(); ctx.arc(sunX,sunY,sunR,0,Math.PI*2); ctx.fill();

    // subtle star tint near dusk (cheap)
    if(sunArc < 0.2){
      ctx.globalAlpha = clamp(0.25 - sunArc*1.2, 0, 0.25);
      ctx.fillStyle = 'rgba(255,255,255,0.02)';
      for(let i=0;i<40;i++){ ctx.fillRect((i*73)%canvas.width, (i*47)%canvas.height, 1,1); }
      ctx.globalAlpha = 1;
    }

    // clouds in screen space (parallax)
    for(const c of clouds){
      const parallax = 0.32 + 0.45*(1 - c.scale);
      const cx = ((c.x - camera.x*parallax) % (WORLD_W*TILE + 800)) - 400;
      const cy = c.y + Math.sin((c.x + performance.now()*0.00014*c.speed) * 0.001) * 6;
      ctx.globalAlpha = c.alpha;
      drawCloud(cx,cy,c.scale);
      ctx.globalAlpha = 1;
    }
  }
  function drawCloud(x,y,s){
    ctx.save(); ctx.translate(x,y); ctx.scale(s,s);
    ctx.fillStyle = 'rgba(255,255,255,0.92)';
    ctx.beginPath(); ctx.ellipse(0,0,46,22,0,0,Math.PI*2); ctx.ellipse(-34,4,28,16,0,0,Math.PI*2); ctx.ellipse(34,4,28,16,0,0,Math.PI*2); ctx.fill();
    ctx.restore();
  }

  // offscreen rendering of tiles
  function renderTilesToBuffer(){
    // tileCanvas size depends on world (constrain max for safety)
    tileCanvas.width = WORLD_W * TILE;
    tileCanvas.height = WORLD_H * TILE;
    tileCtx = tileCanvas.getContext('2d');
    tileCtx.imageSmoothingEnabled = false;
    // background
    tileCtx.clearRect(0,0,tileCanvas.width,tileCanvas.height);
    // draw tiles
    for(let tx=0; tx<WORLD_W; tx++){
      for(let ty=0; ty<WORLD_H; ty++){
        const t = tiles[idx(tx,ty)];
        if(!t) continue;
        const px = tx*TILE, py = ty*TILE;
        if(t === 1){ // ground
          // base
          tileCtx.fillStyle = '#6B3E1E'; tileCtx.fillRect(px,py,TILE,TILE);
          // top grass
          if(ty>0 && tiles[idx(tx,ty-1)]===0){
            tileCtx.fillStyle = '#2CA02C'; tileCtx.fillRect(px,py, TILE, Math.floor(TILE*0.28));
          } else {
            // subtle shading
            tileCtx.fillStyle = 'rgba(0,0,0,0.06)'; tileCtx.fillRect(px+0.5, py+TILE-6, TILE-1, 2);
          }
          tileCtx.strokeStyle = 'rgba(0,0,0,0.12)'; tileCtx.strokeRect(px+0.5, py+0.5, TILE-1, TILE-1);
        } else if(t === 2){ // water
          // draw a blue tile base; water animation done in main render
          tileCtx.fillStyle = '#2a6ea6'; tileCtx.fillRect(px,py,TILE,TILE);
        }
      }
    }
    // after drawing base, we may draw mountain peaks highlights (optional)
  }

  // water draw (animated) - draws on main canvas over tile buffer
  function drawWaterOverlay(offset){
    // basic wave animation using a sine offset for top edge highlight
    const viewW = canvas.width / camera.scale, viewH = canvas.height / camera.scale;
    const startX = Math.floor(camera.x / TILE) - 2, endX = Math.ceil((camera.x + viewW) / TILE) + 2;
    const startY = Math.floor(camera.y / TILE) - 2, endY = Math.ceil((camera.y + viewH) / TILE) + 2;

    for(let tx = Math.max(0,startX); tx<=Math.min(WORLD_W-1,endX); tx++){
      for(let ty = Math.max(0,startY); ty<=Math.min(WORLD_H-1,endY); ty++){
        if(tiles[idx(tx,ty)] !== 2) continue;
        const px = tx*TILE, py = ty*TILE;
        // water base (semi transparent)
        ctx.globalAlpha = 0.62;
        ctx.fillStyle = '#2a6ea6';
        ctx.fillRect(px, py, TILE, TILE);
        ctx.globalAlpha = 1;
        // surface shine - small sin wave
        const wx = Math.sin((tx*0.4 + offset*0.02)) * 4;
        ctx.fillStyle = 'rgba(255,255,255,0.05)';
        ctx.fillRect(px+2+wx, py+2, TILE-4, 2);
      }
    }

    // soft reflection: draw thin mirror of topmost ground rows slightly offset and blurred (cheap: draw small rects)
    ctx.globalCompositeOperation = 'lighter';
    ctx.globalAlpha = 0.08;
    for(let tx = Math.max(0,startX); tx<=Math.min(WORLD_W-1,endX); tx++){
      for(let ty = Math.max(0,startY); ty<=Math.min(WORLD_H-2,endY); ty++){
        if(tiles[idx(tx,ty)] === 1 && tiles[idx(tx,ty+1)] === 2){
          // draw a small mirrored rect
          const px = tx*TILE, py = (ty+1)*TILE;
          ctx.fillStyle = '#ffffff';
          ctx.fillRect(px+4, py+4, TILE-8, 4);
        }
      }
    }
    ctx.globalAlpha = 1; ctx.globalCompositeOperation = 'source-over';
  }

  // physics & game loop
  let last = performance.now(), acc = 0, STEP = 1/60, frames=0, fps=0, fpsTimer=0;
  let footCooldown=0, gameStarted=false;
  let paused = false;

  function physicsStep(){
    // simple fps-friendly behaviour when tab is hidden
    if(document.hidden) return;

    let target = 0; if(input.left) target -= MAX_SPEED; if(input.right) target += MAX_SPEED;
    const accel = player.onGround ? GROUND_ACCEL : AIR_ACCEL;
    player.vx = moveToward(player.vx, target, accel * STEP);
    player.vy += GRAVITY * STEP; if(player.vy > MAX_FALL) player.vy = MAX_FALL;
    coyoteTimer -= STEP; if(player.onGround) coyoteTimer = COYOTE_TIME;
    if(jumpBufferTimer > 0) jumpBufferTimer -= STEP;
    if(jumpBufferTimer > 0 && coyoteTimer > 0){ player.vy = -JUMP_SPEED; player.onGround=false; coyoteTimer=0; jumpBufferTimer=0; }
    if(!input.jumpHeld && player.vy < 0){ if(player.vy < -JUMP_CUTOFF) player.vy = -JUMP_CUTOFF; }
    footCooldown -= STEP;
    if(player.onGround && Math.abs(player.vx) > 40 && footCooldown<=0){ spawnFootParticles(); footCooldown = 0.06; }

    // cheap particle update
    for(let i=particles.length-1;i>=0;i--){
      const p = particles[i]; p.vy += GRAVITY*0.38*STEP; p.x += p.vx*STEP; p.y += p.vy*STEP; p.age += STEP;
      if(p.age >= p.life) particles.splice(i,1);
    }

    const res = resolveCollision(player.x, player.y, player.w, player.h, player.vx, player.vy, STEP);
    player.x = res.x; player.y = res.y; player.vx = res.vx; player.vy = res.vy; player.onGround = res.onGround;
    if(player.vx < -1) player.facing = -1; if(player.vx > 1) player.facing = 1;
  }

  function updateCamera(){
    const targetX = player.x - (canvas.width / (2 * camera.scale));
    const targetY = player.y - (canvas.height / (2 * camera.scale));
    camera.x += (targetX - camera.x) * 0.12; camera.y += (targetY - camera.y) * 0.12;
    camera.scale += (camera.targetScale - camera.scale) * 0.12;
    if(Math.abs(camera.scale - camera.targetScale) < 0.001) camera.scale = camera.targetScale;
    camera.x = clamp(camera.x, 0, Math.max(0, WORLD_W*TILE - canvas.width/camera.scale));
    camera.y = clamp(camera.y, 0, Math.max(0, WORLD_H*TILE - canvas.height/camera.scale));
  }

  function draw(){
    // draw sky (screen-space)
    ctx.save();
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
    drawSky();
    ctx.restore();

    // draw tile buffer scaled & translated
    ctx.save();
    ctx.imageSmoothingEnabled = false;
    ctx.scale(camera.scale, camera.scale);
    ctx.translate(-Math.floor(camera.x), -Math.floor(camera.y));
    // blit tileCanvas (fast)
    ctx.drawImage(tileCanvas, 0, 0);
    // draw water overlay
    drawWaterOverlay(waterOffset);

    // draw particles (behind player but above tiles)
    for(const p of particles){
      const alpha = 1 - (p.age / p.life);
      if(alpha <= 0) continue;
      ctx.globalAlpha = alpha;
      ctx.fillStyle = '#d9c6a6';
      const sx = Math.round(p.x - p.size/2), sy = Math.round(p.y - p.size/2);
      ctx.fillRect(sx, sy, Math.max(1, Math.round(p.size)), Math.max(1, Math.round(p.size)));
    }
    ctx.globalAlpha = 1;

    // draw player
    const px = Math.floor(player.x - player.w/2), py = Math.floor(player.y - player.h/2);
    ctx.fillStyle = '#fff'; ctx.fillRect(px, py, player.w, player.h);
    ctx.fillStyle = '#0066cc'; ctx.fillRect(px+3, py+8, player.w-6, player.h-10);
    ctx.fillStyle = '#000'; ctx.fillRect(px + (player.facing===1 ? player.w-7 : 4), py+8, 3, 3);
    ctx.strokeStyle = 'rgba(0,0,0,0.6)'; ctx.strokeRect(px, py, player.w, player.h);

    ctx.restore();

    // HUD
    hud.innerHTML = `x:${Math.round(player.x)} y:${Math.round(player.y)} vx:${Math.round(player.vx)} vy:${Math.round(player.vy)} fps:${Math.round(fps)} zoom:${camera.scale.toFixed(2)}`;
  }

  // animation frame
  function frame(now){
    const dt_real = (now - last) / 1000; last = now;
    acc += dt_real; if(acc > 0.25) acc = 0.25;
    // throttle physics when hidden
    const stepsToDo = document.hidden ? 0 : Math.max(0, Math.floor(acc / STEP));
    let used = 0;
    while(acc >= STEP && used < 3){ physicsStep(); acc -= STEP; used++; }
    // update camera & draw
    updateCamera();
    // animate water offset & simple cloud movement
    waterOffset += dt_real * 60;
    for(const c of clouds) c.x += (c.speed*dt_real*0.18);
    // wrap clouds
    for(const c of clouds) if(c.x > WORLD_W*TILE + 600) c.x = -600;

    draw();

    frames++; fpsTimer += dt_real;
    if(fpsTimer >= 0.5){ fps = Math.round(frames / fpsTimer); frames = 0; fpsTimer = 0; }

    requestAnimationFrame(frame);
  }

  // ---------- Generation ----------

  // Generate terrain seeded: two modes
  async function generateTerrain(seedStr, rng, mode='mainland'){
    // allocate arrays
    tiles = new Uint8Array(WORLD_W * WORLD_H);
    heightMap = new Array(WORLD_W);

    // show loader and progress
    loadingOverlay.style.display = 'flex';
    loaderFill.style.width = '0%'; loaderText.textContent = '0%';
    let progressIdx = 0;

    // parameters influenced by mode
    const seaLevel = mode === 'islands' ? Math.floor(WORLD_H*0.46) : Math.floor(WORLD_H*0.5);
    // base noise seeds
    const seeds = 10; const seedVals = [];
    for(let i=0;i<seeds;i++) seedVals.push(rng()*6 - 3);

    // For islands: create island centers then blend with noise
    let islandCenters = [];
    if(mode === 'islands'){
      const islandCount = Math.max(3, Math.floor(WORLD_W / 60));
      for(let i=0;i<islandCount;i++){
        islandCenters.push({cx: Math.floor(rng()*WORLD_W), radius: Math.floor(6 + rng()*16), height: Math.floor(4 + rng()*8)});
      }
    }

    // mainland lakes / mountains
    let mountainPeaks = [];
    if(mode === 'mainland'){
      const peakCount = Math.max(2, Math.floor(WORLD_W / 140));
      for(let i=0;i<peakCount;i++){
        mountainPeaks.push({cx: Math.floor(rng()*WORLD_W), radius: Math.floor(14 + rng()*40), height: Math.floor(6 + rng()*14)});
      }
    }

    // progressive column generation in chunks (keeps UI responsive)
    const chunk = 6;
    for(let x=0;x<WORLD_W;x++){
      let v = 0;
      v += Math.sin(x*0.018) * (3.2 + rng()*1.2);
      v += Math.sin(x*0.0048) * (7 + rng()*3);
      v += Math.sin(x*0.11) * (1.2 + rng()*0.6);
      const t = (x/WORLD_W)*(seeds-1);
      const i0 = Math.floor(t), f = t - i0;
      const a = seedVals[i0 % seeds], b = seedVals[(i0+1) % seeds];
      v += (a*(1-f) + b*f) * 3.4;

      // mode-specific modifications
      if(mode === 'islands'){
        // compute island influence
        let influence = 0;
        for(const isl of islandCenters){
          const d = Math.abs(isl.cx - x);
          const fall = Math.max(0, 1 - (d / (isl.radius*4)));
          influence += fall * isl.height;
        }
        v += influence;
      } else {
        // mainland mountains peaks
        for(const p of mountainPeaks){
          const d = Math.abs(p.cx - x);
          if(d < p.radius){
            const fall = Math.cos((d / p.radius) * Math.PI) * 1.0;
            v += fall * p.height * (0.7 + rng()*0.6);
          }
        }
      }

      let base = Math.floor(WORLD_H*0.5 + v);
      // islands bias: lower average so more water
      if(mode === 'islands') base = Math.floor(seaLevel - 1 + v*0.6);
      // clamp
      if(base > WORLD_H-2) base = WORLD_H-2;
      if(base < 4) base = 4;
      heightMap[x] = base;
      // fill column
      for(let y=base; y<WORLD_H; y++) tiles[idx(x,y)] = 1;

      // update progress occasionally
      if(x % chunk === 0){
        progressIdx = Math.round((x/(WORLD_W-1))*100);
        loaderFill.style.width = progressIdx + '%';
        loaderText.textContent = progressIdx + '%';
        await new Promise(r=>setTimeout(r,0)); // yield so browser paints
      }
    }

    // floating platforms & islands tweaks
    if(mode === 'islands'){
      // carve sea: mark tiles below seaLevel as water
      for(let x=0;x<WORLD_W;x++){
        for(let y=heightMap[x]; y<WORLD_H; y++) tiles[idx(x,y)] = 2; // water
      }
      // ensure islands have some sand/flat top - add small lumpy floating bits
      for(let i=0;i<Math.floor(WORLD_W/6);i++){
        const px = Math.floor(rng()*WORLD_W);
        const py = Math.floor(Math.max(4, heightMap[px] - (1 + Math.floor(rng()*3))));
        const len = Math.floor(1 + rng()*5);
        for(let x=px; x<Math.min(WORLD_W, px+len); x++) tiles[idx(x,py)] = 1;
      }
    } else {
      // mainland: one lake (carve)
      if(rng() < 0.95){
        const lakeCenter = Math.floor(rng()*WORLD_W);
        const lakeRadius = Math.floor(8 + rng()*22);
        const lakeDepth = Math.floor(2 + rng()*4);
        for(let x=Math.max(0,lakeCenter-lakeRadius); x<=Math.min(WORLD_W-1,lakeCenter+lakeRadius); x++){
          const d = Math.abs(x - lakeCenter);
          const floor = heightMap[x] + Math.floor(Math.max(0, (lakeRadius - d) * (lakeDepth/lakeRadius)));
          for(let y=floor; y<WORLD_H; y++) tiles[idx(x,y)] = 2; // water
        }
      }
      // add some floating platforms
      for(let i=0;i<Math.floor(WORLD_W/12);i++){
        const px = Math.floor(rng()*WORLD_W);
        const py = Math.floor(rng()*(WORLD_H/3)) + 6;
        const len = Math.floor(1 + rng()*4);
        for(let x=px; x<Math.min(WORLD_W, px+len); x++) tiles[idx(x,py)] = 1;
      }
    }

    // done: render tiles to offscreen buffer
    renderTilesToBuffer();

    // clouds and particles reset
    makeClouds(rng);
    particles = [];

    // done progress
    loaderFill.style.width = '100%';
    loaderText.textContent = '100%';
    // small fade
    await new Promise(r=>setTimeout(r,380));
    loadingOverlay.style.display = 'none';
    loaderFill.style.width = '0%';
    loaderText.textContent = '0%';
  }

  // ---------- Mini-preview rendering for menu ----------
  function renderMiniPreview(seedStr, rng, mode){
    // small preview grid based on width (but not full width)
    const pw = miniCanvas.width, ph = miniCanvas.height;
    miniCtx.clearRect(0,0,pw,ph);
    const cols = Math.min(120, WORLD_W);
    const rows = Math.min(48, WORLD_H);
    const cellW = Math.floor(pw/cols), cellH = Math.floor(ph/rows);
    // simple hashed height map for preview (cheap)
    const seeds = 6; const seedVals=[];
    for(let i=0;i<seeds;i++) seedVals.push(rng()*6 - 3);
    for(let x=0;x<cols;x++){
      let v=0;
      v += Math.sin(x*0.02) * 3.5;
      v += Math.sin(x*0.005) * 8.0;
      v += Math.sin(x*0.11) * 1.3;
      const t = (x/cols)*(seeds-1); const i0=Math.floor(t), f=t-i0;
      const a = seedVals[i0%seeds], b=seedVals[(i0+1)%seeds];
      v += (a*(1-f)+b*f) * 3.0;
      let h = Math.floor(rows*0.5 + v);
      if(h > rows-2) h = rows-2; if(h < 4) h = 4;
      if(mode === 'islands') h = Math.floor(rows*0.46 + v*0.55);
      for(let y=h; y<rows; y++){
        const px = x*cellW, py = y*cellH;
        if(mode === 'islands'){
          miniCtx.fillStyle = '#2a6ea6'; miniCtx.fillRect(px,py,cellW,cellH); // water
        } else {
          miniCtx.fillStyle = '#6B3E1E'; miniCtx.fillRect(px,py,cellW,cellH);
        }
      }
      // top soil pixel
      miniCtx.fillStyle = '#2CA02C'; miniCtx.fillRect(x*cellW, (h-1)*cellH, cellW, cellH);
    }
    // decorate
    miniCtx.globalAlpha = 0.12; miniCtx.fillStyle = '#000'; miniCtx.fillRect(0,0,pw,4); miniCtx.globalAlpha=1;
  }

  // ---------- UI wiring ----------
  function makeRandomSeed(){
    const A = ["Misty","Silent","Neon","Crimson","Lone","Windy","Blue","Solar","Frost","Echo"];
    const B = ["Island","Grove","Plateau","Dunes","Reach","Cavern","Shore","Vale","Ridge","Haven"];
    return A[Math.floor(Math.random()*A.length)] + B[Math.floor(Math.random()*B.length)] + Math.floor(Math.random()*900);
  }

  randomBtn.addEventListener('click', ()=>{ seedInput.value = makeRandomSeed(); updateSeedPreview(); });
  copySeed.addEventListener('click', ()=>{ navigator.clipboard?.writeText(seedInput.value || '') });

  widthRange.addEventListener('input', ()=>{ widthVal.textContent = widthRange.value; updateSizeLabel(); });
  heightRange.addEventListener('input', ()=>{ heightVal.textContent = heightRange.value; updateSizeLabel(); });

  function updateSeedPreview(){
    const h = xfnv1a(seedInput.value || '');
    seedHex.textContent = h.toString(16).padStart(8,'0').toUpperCase();
  }
  function updateSizeLabel(){ sizeLabel.textContent = `${widthRange.value}×${heightRange.value}`; }
  function updateModeLabel(){ modeLabel.textContent = `Mode: ${worldTypeSel.value}`; }

  seedInput.addEventListener('input', ()=>{ updateSeedPreview(); });
  worldTypeSel.addEventListener('change', ()=>{ updateModeLabel(); });
  updateSeedPreview(); updateModeLabel(); updateSizeLabel();

  // regen preview button
  regenBtn.addEventListener('click', async ()=>{
    // quick preview generation (mini)
    WORLD_W = parseInt(widthRange.value,10); WORLD_H = parseInt(heightRange.value,10);
    const seed = seedInput.value || makeRandomSeed();
    const seedNum = xfnv1a(seed);
    const rng = mulberry32(seedNum);
    renderMiniPreview(seed, rng, worldTypeSel.value);
  });

  // play button -> start game & hide menu
  playBtn.addEventListener('click', async ()=>{
    menu.style.display = 'none';
    hud.innerHTML = 'Generating world...';
    WORLD_W = parseInt(widthRange.value,10);
    WORLD_H = parseInt(heightRange.value,10);
    camera.targetScale = Number(startZoomSel.value) || 2;
    camera.scale = camera.targetScale;

    const seed = seedInput.value || makeRandomSeed();
    const seedNum = xfnv1a(seed);
    const rng = mulberry32(seedNum);
    updateSeedPreview();
    // generate terrain
    await generateTerrain(seed, rng, worldTypeSel.value);
    // set player spawn relative to heightmap
    const spawnX = Math.min(5, WORLD_W-6);
    player.x = spawnX*TILE + TILE/2;
    player.y = (heightMap[spawnX] - 2) * TILE;
    camera.x = player.x - (canvas.width/(2*camera.scale));
    camera.y = player.y - (canvas.height/(2*camera.scale));
    hud.innerHTML = 'World ready — enjoy!';
    if(!gameStarted){ last = performance.now(); gameStarted=true; requestAnimationFrame(frame); }
  });

  // mini preview initial generate
  seedInput.value = makeRandomSeed(); updateSeedPreview();
  regenBtn.click();

  // keyboard small helper: press Esc shows menu
  window.addEventListener('keydown', e=>{ if(e.key === 'Escape'){ menu.style.display = menu.style.display === 'none' ? 'flex' : 'none'; } });

  // initial quick start (menu requires Play)
  // safety: ensure tileCanvas has some minimal size
  tileCanvas.width = WORLD_W*TILE; tileCanvas.height = WORLD_H*TILE;

  // give user ability to preview the generated world while menu open: regenerate preview periodically
  let previewTimer = setInterval(()=>{ if(menu.style.display !== 'none'){ regenBtn.click(); } }, 5000);

  // done
})();
</script>
</body>
</html>

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Pixel Worlds — Single File HTML Demo</title>
  <style>
    html,body{height:100%;margin:0;background:#111;color:#ddd;font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,'Helvetica Neue',Arial}
    canvas{display:block;background:linear-gradient(#80c1ff 0%, #a8e6ff 35%, #87c77f 36%, #6ea25c 100%);image-rendering: pixelated;}
    .overlay{position:fixed;left:10px;top:10px;z-index:10;background:rgba(0,0,0,0.35);padding:8px;border-radius:6px;font-size:13px}
    .small{opacity:.85;font-size:12px}
    .hint{position:fixed;right:10px;bottom:10px;background:rgba(0,0,0,0.35);padding:8px;border-radius:6px;font-size:13px}
    a{color:#9fe0ff}
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <div class="overlay" id="hud">Loading...</div>
  <div class="hint">Controls: ←/A, →/D to move — Space / W / ↑ to jump — Hold jump for higher jump</div>

<script>
/*
  Pixel Worlds-like platformer demo (updated with pixel-perfect zoom snapping and foot particles)
  - Wheel zoom snaps to visual pixel scales (0.5, 1, 2, 3, 4) after user stops scrolling
  - Camera keeps the world point under cursor during zoom
  - Particle effect at player's feet while walking on terrain
  - Movement still uses tight walking acceleration
*/

(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const hud = document.getElementById('hud');

  // --- Display & scaling ---
  function resize(){ canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
  window.addEventListener('resize', resize); resize();

  // --- World constants ---
  const TILE = 32; const WORLD_W = 300; const WORLD_H = 40;

  // --- Tiles ---
  const tiles = new Uint8Array(WORLD_W * WORLD_H);
  function makeHeightMap(w){
    const h = new Array(w); const seeds = 8; const seedVals = [];
    for(let i=0;i<seeds;i++) seedVals.push(Math.random()*6 - 3);
    for(let x=0;x<w;x++){
      let v = 0; v += Math.sin(x*0.02) * 3.5; v += Math.sin(x*0.005)*8.0; v += Math.sin(x*0.11)*1.5;
      const t = (x/w)*(seeds-1); const i0 = Math.floor(t), f = t - i0;
      const a = seedVals[i0 % seeds]; const b = seedVals[(i0+1) % seeds]; v += (a*(1-f) + b*f) * 3.0;
      h[x] = Math.floor(WORLD_H*0.5 + v);
      if(h[x] > WORLD_H-2) h[x] = WORLD_H-2; if(h[x] < 6) h[x] = 6;
    }
    return h;
  }
  const heightMap = makeHeightMap(WORLD_W);
  for(let x=0;x<WORLD_W;x++){ const ground = heightMap[x]; for(let y=ground; y<WORLD_H; y++) tiles[y*WORLD_W + x] = 1; }
  for(let i=0;i<60;i++){ const px = Math.floor(Math.random() * (WORLD_W-8)); const py = Math.floor(Math.random() * (WORLD_H/2)) + 6; const len = Math.floor(Math.random()*5) + 2; for(let x=px; x<px+len; x++) tiles[py*WORLD_W + x] = 1; }

  // --- Player ---
  const player = { x: TILE*5 + TILE/2, y: (heightMap[5] - 2)*TILE, w:22, h:28, vx:0, vy:0, onGround:false, facing:1 };

  // --- Physics params ---
  const GRAVITY = 1400; const MAX_FALL = 1400; const MAX_SPEED = 220; const GROUND_ACCEL = 14000; const AIR_ACCEL = 3200; const JUMP_SPEED = 520; const JUMP_CUTOFF = 200; const COYOTE_TIME = 0.10; const JUMP_BUFFER = 0.10;
  let coyoteTimer = 0; let jumpBufferTimer = 0;

  // --- Input ---
  const input = {left:false,right:false,jump:false,jumpHeld:false};
  window.addEventListener('keydown', e => { if(e.code === 'ArrowLeft' || e.code === 'KeyA'){ input.left = true; } if(e.code === 'ArrowRight' || e.code === 'KeyD'){ input.right = true; } if(e.code === 'ArrowUp' || e.code === 'KeyW' || e.code === 'Space'){ if(!input.jump){ input.jump = true; input.jumpHeld = true; jumpBufferTimer = JUMP_BUFFER; } } });
  window.addEventListener('keyup', e => { if(e.code === 'ArrowLeft' || e.code === 'KeyA'){ input.left = false; } if(e.code === 'ArrowRight' || e.code === 'KeyD'){ input.right = false; } if(e.code === 'ArrowUp' || e.code === 'KeyW' || e.code === 'Space'){ input.jumpHeld = false; input.jump = false; } });

  // --- Tile helpers ---
  function tileAt(tx, ty){ if(tx < 0 || tx >= WORLD_W || ty < 0 || ty >= WORLD_H) return 1; return tiles[ty*WORLD_W + tx]; }
  function worldToTile(px){ return Math.floor(px / TILE); }

  // --- Collision resolver ---
  function resolveCollision(px, py, w, h, vx, vy, dt){
    let nx = px, ny = py, nvx = vx, nvy = vy;
    nx += nvx * dt; let left = worldToTile(nx - w/2); let right = worldToTile(nx + w/2 - 0.0001); let top = worldToTile(ny - h/2); let bottom = worldToTile(ny + h/2 - 0.0001);
    for(let ty = top; ty <= bottom; ty++){
      if(tileAt(left, ty)){ nx = (left+1)*TILE + w/2 + 0.001; nvx = 0; left = worldToTile(nx - w/2); }
      if(tileAt(right, ty)){ nx = (right)*TILE - w/2 - 0.001; nvx = 0; right = worldToTile(nx + w/2 - 0.0001); }
    }
    ny += nvy * dt; left = worldToTile(nx - w/2); right = worldToTile(nx + w/2 - 0.0001); top = worldToTile(ny - h/2); bottom = worldToTile(ny + h/2 - 0.0001);
    let onGround = false;
    for(let tx = left; tx <= right; tx++){
      if(tileAt(tx, top)){ ny = (top+1)*TILE + h/2 + 0.001; nvy = 0; top = worldToTile(ny - h/2); }
      if(tileAt(tx, bottom)){ ny = (bottom)*TILE - h/2 - 0.001; nvy = 0; bottom = worldToTile(ny + h/2 - 0.0001); onGround = true; }
    }
    return {x:nx,y:ny,vx:nvx,vy:nvy,onGround};
  }

  // --- Camera & Pixel-Scale Zoom ---
  const camera = { x:0, y:0, scale:1, targetScale:1 };
  const allowedScales = [0.5, 1, 2, 3, 4];
  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

  // zoom snapping: wait a short time after wheel events then snap target to nearest allowed scale
  let snapTimer = null;
  function scheduleSnap(){ if(snapTimer) clearTimeout(snapTimer); snapTimer = setTimeout(() => { // snap now
      // find nearest allowed scale to current targetScale
      let nearest = allowedScales[0]; let bestd = Math.abs(camera.targetScale - nearest);
      for(const s of allowedScales){ const d = Math.abs(camera.targetScale - s); if(d < bestd){ bestd = d; nearest = s; } }
      // preserve world point under cursor when snapping
      const rect = canvas.getBoundingClientRect(); const mx = lastMouse.x - rect.left, my = lastMouse.y - rect.top;
      const worldBeforeX = camera.x + mx / camera.targetScale; const worldBeforeY = camera.y + my / camera.targetScale;
      camera.targetScale = nearest;
      const worldAfterX = camera.x + mx / camera.targetScale; const worldAfterY = camera.y + my / camera.targetScale;
      camera.x += (worldAfterX - worldBeforeX); camera.y += (worldAfterY - worldBeforeY);
      snapTimer = null;
    }, 180); }

  // track last mouse position for snap centering
  const lastMouse = {x: canvas.width/2, y: canvas.height/2};
  window.addEventListener('mousemove', e => { lastMouse.x = e.clientX; lastMouse.y = e.clientY; });

  window.addEventListener('wheel', (e) => {
    const prevTarget = camera.targetScale;
    const zoomFactor = Math.pow(1.0018, -e.deltaY);
    let newTarget = clamp(camera.targetScale * zoomFactor, allowedScales[0], allowedScales[allowedScales.length-1]);
    // keep world point under cursor stable immediately
    const rect = canvas.getBoundingClientRect(); const sx = e.clientX - rect.left, sy = e.clientY - rect.top;
    const worldBeforeX = camera.x + sx / camera.targetScale; const worldBeforeY = camera.y + sy / camera.targetScale;
    camera.targetScale = newTarget;
    const worldAfterX = camera.x + sx / camera.targetScale; const worldAfterY = camera.y + sy / camera.targetScale;
    camera.x += (worldAfterX - worldBeforeX); camera.y += (worldAfterY - worldBeforeY);
    scheduleSnap();
  }, {passive:true});

  // double-click reset
  canvas.addEventListener('dblclick', () => { camera.targetScale = 1.0; });

  // --- Particle system (foot dust) ---
  const particles = [];
  function spawnFootParticles(){
    // spawn a few small particles near player's feet
    const footX = player.x + (player.facing === 1 ? player.w*0.18 : -player.w*0.18);
    const footY = player.y + player.h/2 - 4;
    const count = Math.random() < 0.5 ? 1 : 2;
    for(let i=0;i<count;i++){
      particles.push({ x: footX + (Math.random()-0.5)*8, y: footY + (Math.random()-0.5)*4, vx: (Math.random()-0.5)*80 + player.vx*0.15, vy: -Math.random()*120 - 20, life: 0.45 + Math.random()*0.25, age: 0, size: 2 + Math.random()*2 });
      // limit particles array to avoid runaway
      if(particles.length > 200) particles.shift();
    }
  }

  // --- Movement helpers ---
  function moveToward(v, target, maxDelta){ if(v < target) return Math.min(v + maxDelta, target); if(v > target) return Math.max(v - maxDelta, target); return v; }

  // --- Game loop & physics ---
  let last = performance.now(); let acc = 0; const STEP = 1/60; window.dt = STEP; let frames = 0, fps = 0, fpsTimer = 0;
  let footParticleCooldown = 0;

  function physicsStep(){
    // horizontal
    let target = 0; if(input.left) target -= MAX_SPEED; if(input.right) target += MAX_SPEED; const accel = player.onGround ? GROUND_ACCEL : AIR_ACCEL; player.vx = moveToward(player.vx, target, accel * STEP);
    // gravity
    player.vy += GRAVITY * STEP; if(player.vy > MAX_FALL) player.vy = MAX_FALL;
    // timers
    coyoteTimer -= STEP; if(player.onGround) coyoteTimer = COYOTE_TIME; if(jumpBufferTimer > 0) jumpBufferTimer -= STEP;
    // jumping
    if(jumpBufferTimer > 0 && coyoteTimer > 0){ player.vy = -JUMP_SPEED; player.onGround = false; coyoteTimer = 0; jumpBufferTimer = 0; }
    if(!input.jumpHeld && player.vy < 0){ if(player.vy < -JUMP_CUTOFF) player.vy = -JUMP_CUTOFF; }
    // spawn foot particles when walking on ground
    footParticleCooldown -= STEP;
    if(player.onGround && Math.abs(player.vx) > 40){ if(footParticleCooldown <= 0){ spawnFootParticles(); footParticleCooldown = 0.06; } }

    // update particles physics
    for(let i=particles.length-1;i>=0;i--){ const p = particles[i]; p.vy += GRAVITY * 0.5 * STEP; p.x += p.vx * STEP; p.y += p.vy * STEP; p.age += STEP; if(p.age >= p.life) particles.splice(i,1); }

    // collision
    const res = resolveCollision(player.x, player.y, player.w, player.h, player.vx, player.vy, STEP);
    player.x = res.x; player.y = res.y; player.vx = res.vx; player.vy = res.vy; player.onGround = res.onGround;
    if(player.vx < -1) player.facing = -1; if(player.vx > 1) player.facing = 1;
  }

  function draw(){
    ctx.save(); ctx.imageSmoothingEnabled = false; ctx.clearRect(0,0,canvas.width,canvas.height);
    // apply scale and camera translation
    ctx.scale(camera.scale, camera.scale);
    // use Math.floor for camera pos to help pixel crispness when scale is integer
    ctx.translate(-Math.floor(camera.x), -Math.floor(camera.y));

    // visible tiles
    const viewW = canvas.width / camera.scale; const viewH = canvas.height / camera.scale;
    const startX = Math.floor(camera.x / TILE) - 1; const endX = Math.ceil((camera.x + viewW) / TILE) + 1;
    const startY = Math.floor(camera.y / TILE) - 1; const endY = Math.ceil((camera.y + viewH) / TILE) + 1;
    for(let tx = startX; tx <= endX; tx++){
      for(let ty = startY; ty <= endY; ty++){
        if(tx<0||tx>=WORLD_W||ty<0||ty>=WORLD_H) continue;
        const t = tileAt(tx,ty); if(!t) continue;
        let isTop = false; if(!tileAt(tx, ty-1)) isTop = true; const px = tx * TILE; const py = ty * TILE;
        ctx.fillStyle = '#6B3E1E'; ctx.fillRect(px, py, TILE, TILE);
        if(isTop){ ctx.fillStyle = '#2CA02C'; ctx.fillRect(px, py, TILE, Math.floor(TILE*0.28)); }
        ctx.strokeStyle = 'rgba(0,0,0,0.12)'; ctx.strokeRect(px+0.5, py+0.5, TILE-1, TILE-1);
      }
    }

    // draw particles (behind player)
    for(const p of particles){ const alpha = 1 - (p.age / p.life); ctx.globalAlpha = Math.max(0, alpha); ctx.fillStyle = '#d9c6a6'; const sx = Math.round(p.x - p.size/2), sy = Math.round(p.y - p.size/2); ctx.fillRect(sx, sy, Math.max(1, Math.round(p.size)), Math.max(1, Math.round(p.size))); }
    ctx.globalAlpha = 1;

    // draw player
    const px = Math.floor(player.x - player.w/2); const py = Math.floor(player.y - player.h/2);
    ctx.fillStyle = '#fefefe'; ctx.fillRect(px, py, player.w, player.h);
    ctx.fillStyle = '#0066cc'; ctx.fillRect(px+3, py+8, player.w-6, player.h-10);
    ctx.fillStyle = '#000'; ctx.fillRect(px + (player.facing===1 ? player.w-7 : 4), py+8, 3, 3);
    ctx.strokeStyle = 'rgba(0,0,0,0.6)'; ctx.strokeRect(px, py, player.w, player.h);

    ctx.restore();
    hud.innerHTML = `x:${Math.round(player.x)} y:${Math.round(player.y)} vx:${Math.round(player.vx)} vy:${Math.round(player.vy)} fps:${Math.round(fps)} zoom:${camera.scale.toFixed(2)}`;
  }

  function updateCamera(){
    const targetX = player.x - (canvas.width / (2 * camera.scale)); const targetY = player.y - (canvas.height / (2 * camera.scale));
    camera.x += (targetX - camera.x) * 0.12; camera.y += (targetY - camera.y) * 0.12;
    // smooth scale toward targetScale but snap to allowed scales when close
    camera.scale += (camera.targetScale - camera.scale) * 0.12;
    // if very close to targetScale, snap precisely (helps keep integer scale exact)
    if(Math.abs(camera.scale - camera.targetScale) < 0.001) camera.scale = camera.targetScale;
    // clamp camera bounds
    camera.x = clamp(camera.x, 0, WORLD_W * TILE - canvas.width / camera.scale);
    camera.y = clamp(camera.y, 0, WORLD_H * TILE - canvas.height / camera.scale);
  }

  function frame(now){
    const dt_real = (now - last) / 1000; last = now; acc += dt_real; if(acc > 0.25) acc = 0.25; while(acc >= STEP){ physicsStep(); acc -= STEP; } updateCamera(); draw(); frames++; fpsTimer += dt_real; if(fpsTimer >= 0.5){ fps = frames / fpsTimer; frames = 0; fpsTimer = 0; } requestAnimationFrame(frame);
  }

  last = performance.now(); requestAnimationFrame(frame);

  // focus canvas
  canvas.tabIndex = 1000; canvas.style.outline = 'none'; canvas.addEventListener('click', () => canvas.focus());
  hud.innerHTML = 'Ready — Click canvas to focus. Controls: ←/A, →/D, Space to jump, wheel to zoom (snaps to pixel scales)';

})();
</script>
</body>
</html>

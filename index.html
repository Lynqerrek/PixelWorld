<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const hud = document.getElementById('hud');

  const TILE = 32; const WORLD_W = 300; const WORLD_H = 40;
  const tiles = new Uint8Array(WORLD_W * WORLD_H);
  let heightMap = new Array(WORLD_W);

  // Generate terrain quickly for demo
  for(let x=0;x<WORLD_W;x++){
    let h = Math.floor(WORLD_H*0.5 + Math.sin(x*0.02)*3 + Math.sin(x*0.11)*2);
    heightMap[x] = h;
    for(let y=h;y<WORLD_H;y++) tiles[y*WORLD_W+x]=1;
  }

  // Player bean setup
  const colors = ['red','blue','green','yellow','purple','orange','cyan','pink'];
  let colorIndex = Math.floor(Math.random()*colors.length);
  const player = { x:TILE*5 + TILE/2, y:TILE*10, w:22, h:28, vx:0, vy:0, onGround:false, facing:1, color: colors[colorIndex] };

  // Switch color each respawn
  function changePlayerColor(){ colorIndex = (colorIndex+1)%colors.length; player.color = colors[colorIndex]; }

  // Simple gravity and ground collision
  const GRAVITY=1400, MAX_FALL=1400, MAX_SPEED=220, GROUND_ACCEL=14000, AIR_ACCEL=3200, JUMP_SPEED=520;
  const input={left:false,right:false,jump:false,jumpHeld:false};
  window.addEventListener('keydown', e=>{ if(e.code==='ArrowLeft'||e.code==='KeyA') input.left=true; if(e.code==='ArrowRight'||e.code==='KeyD') input.right=true; if(e.code==='ArrowUp'||e.code==='KeyW'||e.code==='Space') { input.jump=true; input.jumpHeld=true;} });
  window.addEventListener('keyup', e=>{ if(e.code==='ArrowLeft'||e.code==='KeyA') input.left=false; if(e.code==='ArrowRight'||e.code==='KeyD') input.right=false; if(e.code==='ArrowUp'||e.code==='KeyW'||e.code==='Space'){ input.jump=false; input.jumpHeld=false; } });

  function tileAt(tx,ty){ if(tx<0||tx>=WORLD_W||ty<0||ty>=WORLD_H) return 1; return tiles[ty*WORLD_W+tx]; }
  function worldToTile(px){ return Math.floor(px/TILE); }
  function resolveCollision(px,py,w,h,vx,vy,dt){
    let nx=px+vx*dt, ny=py+vy*dt, nvx=vx,nvy=vy, onGround=false;
    let left=worldToTile(nx-w/2), right=worldToTile(nx+w/2-0.0001), top=worldToTile(ny-h/2), bottom=worldToTile(ny+h/2-0.0001);
    for(let tx=left;tx<=right;tx++){ if(tileAt(tx,top)){ ny=(top+1)*TILE+h/2+0.001;nvy=0;} if(tileAt(tx,bottom)){ ny=bottom*TILE-h/2-0.001;nvy=0; onGround=true; } }
    return {x:nx,y:ny,vx:nvx,vy:nvy,onGround};
  }

  const particles=[];
  function spawnFootParticles(){ const footX=player.x, footY=player.y+player.h/2-4; for(let i=0;i<2;i++){ particles.push({x:footX+(Math.random()-0.5)*8, y:footY, vx:(Math.random()-0.5)*80, vy:-Math.random()*120, life:0.45+Math.random()*0.25, age:0, size:2+Math.random()*2}); if(particles.length>300) particles.shift(); } }

  const camera={x:0,y:0,scale:1,targetScale:1};
  function clamp(v,a,b){return Math.max(a,Math.min(b,v));}

  function moveToward(v,target,maxDelta){if(v<target) return Math.min(v+maxDelta,target); if(v>target) return Math.max(v-maxDelta,target); return v;}

  let last=performance.now(), acc=0; const STEP=1/60; let footParticleCooldown=0;
  function physicsStep(){
    let target=0; if(input.left) target-=MAX_SPEED; if(input.right) target+=MAX_SPEED;
    const accel=player.onGround?GROUND_ACCEL:AIR_ACCEL; player.vx=moveToward(player.vx,target,accel*STEP);
    player.vy+=GRAVITY*STEP; if(player.vy>MAX_FALL) player.vy=MAX_FALL;
    if(input.jump&&player.onGround){ player.vy=-JUMP_SPEED; player.onGround=false; input.jump=false; changePlayerColor(); }
    footParticleCooldown-=STEP; if(player.onGround&&Math.abs(player.vx)>40){ if(footParticleCooldown<=0){ spawnFootParticles(); footParticleCooldown=0.06; } }
    for(let i=particles.length-1;i>=0;i--){ let p=particles[i]; p.vy+=GRAVITY*0.5*STEP; p.x+=p.vx*STEP; p.y+=p.vy*STEP; p.age+=STEP; if(p.age>=p.life) particles.splice(i,1); }
    const res=resolveCollision(player.x,player.y,player.w,player.h,player.vx,player.vy,STEP);
    player.x=res.x; player.y=res.y; player.vx=res.vx; player.vy=res.vy; player.onGround=res.onGround;
  }

  function updateCamera(){
    const targetX=player.x-canvas.width/(2*camera.scale); const targetY=player.y-canvas.height/(2*camera.scale);
    camera.x+=(targetX-camera.x)*0.12; camera.y+=(targetY-camera.y)*0.12;
  }

  function draw(){
    ctx.fillStyle='#87ceeb'; ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.save(); ctx.scale(camera.scale,camera.scale); ctx.translate(-camera.x,-camera.y);
    for(let x=0;x<WORLD_W;x++){ for(let y=0;y<WORLD_H;y++){ if(tileAt(x,y)){ ctx.fillStyle='#6B3E1E'; ctx.fillRect(x*TILE,y*TILE,TILE,TILE); } } }
    for(const p of particles){ ctx.fillStyle='rgba(200,180,140,0.9)'; ctx.fillRect(p.x-1,p.y-1,Math.max(1,p.size),Math.max(1,p.size)); }
    // draw bean player
    ctx.fillStyle=player.color; ctx.beginPath(); ctx.ellipse(player.x, player.y-4, player.w/2, player.h/2, 0, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle='#333'; ctx.beginPath(); ctx.ellipse(player.x+player.w/6*player.facing, player.y-2, player.w/6, player.h/6, 0, 0, Math.PI*2); ctx.fill();
    ctx.restore();
    hud.innerHTML=`x:${Math.round(player.x)} y:${Math.round(player.y)} vx:${Math.round(player.vx)} vy:${Math.round(player.vy)}`;
  }

  function frame(now){ const dt_real=(now-last)/1000; last=now; acc+=dt_real; if(acc>0.25) acc=0.25; while(acc>=STEP){ physicsStep(); acc-=STEP; } updateCamera(); draw(); requestAnimationFrame(frame); }

  canvas.width=window.innerWidth; canvas.height=window.innerHeight; window.addEventListener('resize',()=>{canvas.width=window.innerWidth; canvas.height=window.innerHeight;});
  frame(performance.now());
})();
</script>

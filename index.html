<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Pixel Worlds — Single File HTML Demo (with Menu & Seed)</title>
  <style>
    html,body{height:100%;margin:0;background:#0b1220;color:#ddd;font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,'Helvetica Neue',Arial}
    canvas{display:block;background:linear-gradient(#80c1ff 0%, #a8e6ff 35%, #87c77f 36%, #6ea25c 100%);image-rendering: pixelated;}
    .overlay{position:fixed;left:10px;top:10px;z-index:10;background:rgba(0,0,0,0.35);padding:8px;border-radius:6px;font-size:13px}
    .small{opacity:.85;font-size:12px}
    .hint{position:fixed;right:10px;bottom:10px;background:rgba(0,0,0,0.35);padding:8px;border-radius:6px;font-size:13px}
    a{color:#9fe0ff}

    /* Main menu styles */
    #mainMenu {
      position:fixed; inset:0; display:flex; align-items:center; justify-content:center; z-index:9998;
      background: linear-gradient(180deg, rgba(3,6,10,0.6), rgba(3,6,10,0.7));
      backdrop-filter: blur(6px);
    }
    #menuCard {
      width:520px; max-width:94%; background:linear-gradient(180deg,#061223,#0b1430); border-radius:12px; padding:20px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.6); color:#e7f6ff; font-family: Inter, system-ui, sans-serif;
    }
    #menuCard h1{ margin:0 0 8px 0; font-size:22px; letter-spacing:0.2px; }
    .menu-row{ display:flex; gap:8px; margin-top:12px; align-items:center; }
    .menu-row input[type="text"]{ flex:1; padding:10px 12px; border-radius:8px; border:1px solid rgba(255,255,255,0.06); background:rgba(255,255,255,0.02); color:#eaf6ff; }
    .menu-row input[type="range"]{ width:100%; }
    .btn { padding:10px 12px; border-radius:8px; background:linear-gradient(180deg,#ffd36b,#ffae6b); border:none; cursor:pointer; font-weight:600; }
    .btn.ghost{ background:transparent; border:1px solid rgba(255,255,255,0.06); color:#fff; }
    .muted{ color:#b7c9d9; font-size:13px; opacity:0.9; margin-top:6px; }
    .menu-footer{ margin-top:14px; display:flex; gap:8px; align-items:center; justify-content:space-between; }
    .small-muted{ font-size:12px; color:#9fb7cc; }
    #seedPreview{ font-family:monospace; background:rgba(255,255,255,0.03); padding:6px 8px; border-radius:6px; border:1px solid rgba(255,255,255,0.03); }
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <div class="overlay" id="hud">Ready.</div>
  <div class="hint">Controls: ←/A, →/D to move — Space / W / ↑ to jump — Hold jump for higher jump</div>

  <!-- Main menu -->
  <div id="mainMenu" role="dialog" aria-modal="true">
    <div id="menuCard">
      <h1>Pixel Worlds — Create World</h1>
      <div class="muted">Generate a deterministic world using a seed. Same seed = same terrain.</div>

      <div class="menu-row" style="margin-top:14px">
        <input id="seedInput" type="text" placeholder="Type a seed (e.g. 'MyIsland42')" value="">
        <button class="btn" id="randomSeedBtn" title="Randomize seed">Random</button>
      </div>
      <div class="menu-row" style="margin-top:8px">
        <div style="flex:1">
          <label class="small-muted">World width: <span id="widthVal">300</span></label>
          <input id="widthRange" type="range" min="120" max="700" value="300">
        </div>
        <div style="width:100px">
          <label class="small-muted">Height: <span id="heightVal">40</span></label>
          <input id="heightRange" type="range" min="24" max="80" value="40">
        </div>
      </div>

      <div class="menu-row">
        <div style="flex:1">
          <label class="small-muted">Camera zoom: </label>
          <select id="startZoom" style="width:100%; padding:8px; border-radius:8px; background:rgba(255,255,255,0.02); color:#eaf6ff; border:1px solid rgba(255,255,255,0.04)">
            <option value="1">1x</option>
            <option value="2">2x</option>
            <option value="3">3x</option>
          </select>
        </div>
        <div style="width:160px; display:flex; gap:8px;">
          <button class="btn" id="startBtn">Start</button>
          <button class="btn ghost" id="editorBtn">Quick Regen</button>
        </div>
      </div>

      <div class="menu-footer">
        <div class="small-muted">Seed preview: <span id="seedPreview">—</span></div>
        <div class="small-muted">Deterministic generator • demo</div>
      </div>
    </div>
  </div>

<script>
/*
  Menu + seed-based world generation added to the demo.
  - Seeded RNG (mulberry32) => deterministic terrain
  - World width/height adjustable from menu
  - Randomize seed, preview numeric hash
*/

(() => {
  // DOM
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const hud = document.getElementById('hud');

  // create a loading overlay DOM element dynamically (hidden until needed)
  const loading = document.createElement('div');
  loading.id = 'loadingOverlay';
  Object.assign(loading.style, {
    position: 'fixed', left: 0, top: 0, right: 0, bottom: 0, display: 'none', alignItems: 'center', justifyContent: 'center',
    background: 'linear-gradient(180deg, rgba(7,14,26,0.95), rgba(10,18,34,0.92))', color: '#fff', zIndex: 9999, flexDirection: 'column'
  });
  loading.innerHTML = `
    <div style="text-align:center; max-width:520px; padding:22px; border-radius:10px; backdrop-filter: blur(4px);">
      <div style="font-size:28px; font-weight:700; margin-bottom:8px">Pixel Worlds — Generating</div>
      <div style="font-size:13px; opacity:0.95; margin-bottom:16px">Preparing world, generating terrain and effects…</div>
      <div id="loaderBar" style="width:100%; height:14px; background:rgba(255,255,255,0.08); border-radius:8px; overflow:hidden;">
        <div id="loaderFill" style="height:100%; width:0%; background:linear-gradient(90deg,#ffd36b,#ffae6b);"></div>
      </div>
      <div id="loaderText" style="margin-top:10px; font-size:12px; opacity:0.9">0%</div>
    </div>
  `;
  document.body.appendChild(loading);
  const loaderFill = loading.querySelector('#loaderFill');
  const loaderText = loading.querySelector('#loaderText');

  // resize & display
  function resize(){ canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
  window.addEventListener('resize', resize); resize();

  // TILE and dynamic world size
  const TILE = 32;
  let WORLD_W = 300;
  let WORLD_H = 40;

  // dynamic arrays (will be allocated per-generation)
  let tiles = new Uint8Array(0);
  let heightMap = [];
  let clouds = [];

  // player, physics constants
  const player = { x: TILE*5 + TILE/2, y: TILE*10, w:22, h:28, vx:0, vy:0, onGround:false, facing:1 };
  const GRAVITY = 1400; const MAX_FALL = 1400; const MAX_SPEED = 220; const GROUND_ACCEL = 14000; const AIR_ACCEL = 3200; const JUMP_SPEED = 520; const JUMP_CUTOFF = 200; const COYOTE_TIME = 0.10; const JUMP_BUFFER = 0.10;
  let coyoteTimer = 0; let jumpBufferTimer = 0;

  // input
  const input = {left:false,right:false,jump:false,jumpHeld:false};
  window.addEventListener('keydown', e => {
    if(e.code === 'ArrowLeft' || e.code === 'KeyA') input.left = true;
    if(e.code === 'ArrowRight' || e.code === 'KeyD') input.right = true;
    if(e.code === 'ArrowUp' || e.code === 'KeyW' || e.code === 'Space'){
      if(!input.jump){ input.jump = true; input.jumpHeld = true; jumpBufferTimer = JUMP_BUFFER; }
    }
  });
  window.addEventListener('keyup', e => {
    if(e.code === 'ArrowLeft' || e.code === 'KeyA') input.left = false;
    if(e.code === 'ArrowRight' || e.code === 'KeyD') input.right = false;
    if(e.code === 'ArrowUp' || e.code === 'KeyW' || e.code === 'Space'){ input.jumpHeld = false; input.jump = false; }
  });

  // seeded RNG utilities
  function xfnv1a(str){
    let h = 2166136261 >>> 0;
    for(let i=0;i<str.length;i++){
      h ^= str.charCodeAt(i);
      h = Math.imul(h, 16777619);
    }
    return h >>> 0;
  }
  function mulberry32(a){
    return function(){
      a |= 0;
      a = a + 0x6D2B79F5 | 0;
      let t = Math.imul(a ^ a >>> 15, 1 | a);
      t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
      return ((t ^ t >>> 14) >>> 0) / 4294967296;
    }
  }

  // tile helpers (use dynamic sizes)
  function tileAt(tx, ty){ if(tx < 0 || tx >= WORLD_W || ty < 0 || ty >= WORLD_H) return 1; return tiles[ty*WORLD_W + tx]; }
  function worldToTile(px){ return Math.floor(px / TILE); }

  // collision
  function resolveCollision(px, py, w, h, vx, vy, dt){
    let nx = px, ny = py, nvx = vx, nvy = vy;
    nx += nvx * dt; let left = worldToTile(nx - w/2); let right = worldToTile(nx + w/2 - 0.0001); let top = worldToTile(ny - h/2); let bottom = worldToTile(ny + h/2 - 0.0001);
    for(let ty = top; ty <= bottom; ty++){
      if(tileAt(left, ty)){ nx = (left+1)*TILE + w/2 + 0.001; nvx = 0; left = worldToTile(nx - w/2); }
      if(tileAt(right, ty)){ nx = (right)*TILE - w/2 - 0.001; nvx = 0; right = worldToTile(nx + w/2 - 0.0001); }
    }
    ny += nvy * dt; left = worldToTile(nx - w/2); right = worldToTile(nx + w/2 - 0.0001); top = worldToTile(ny - h/2); bottom = worldToTile(ny + h/2 - 0.0001);
    let onGround = false;
    for(let tx = left; tx <= right; tx++){
      if(tileAt(tx, top)){ ny = (top+1)*TILE + h/2 + 0.001; nvy = 0; top = worldToTile(ny - h/2); }
      if(tileAt(tx, bottom)){ ny = (bottom)*TILE - h/2 - 0.001; nvy = 0; bottom = worldToTile(ny + h/2 - 0.0001); onGround = true; }
    }
    return {x:nx,y:ny,vx:nvx,vy:nvy,onGround};
  }

  // camera & zoom
  const camera = { x:0, y:0, scale:1, targetScale:1 };
  const allowedScales = [0.5, 1, 2, 3, 4];
  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
  let snapTimer = null; const lastMouse = {x: canvas.width/2, y: canvas.height/2}; window.addEventListener('mousemove', e => { lastMouse.x = e.clientX; lastMouse.y = e.clientY; });
  function scheduleSnap(){ if(snapTimer) clearTimeout(snapTimer); snapTimer = setTimeout(() => {
    let nearest = allowedScales[0]; let bestd = Math.abs(camera.targetScale - nearest);
    for(const s of allowedScales){ const d = Math.abs(camera.targetScale - s); if(d < bestd){ bestd = d; nearest = s; } }
    const rect = canvas.getBoundingClientRect(); const mx = lastMouse.x - rect.left, my = lastMouse.y - rect.top;
    const worldBeforeX = camera.x + mx / camera.targetScale; const worldBeforeY = camera.y + my / camera.targetScale;
    camera.targetScale = nearest;
    const worldAfterX = camera.x + mx / camera.targetScale; const worldAfterY = camera.y + my / camera.targetScale;
    camera.x += (worldAfterX - worldBeforeX); camera.y += (worldAfterY - worldBeforeY);
    snapTimer = null;
  }, 180); }
  window.addEventListener('wheel', (e) => {
    const zoomFactor = Math.pow(1.0018, -e.deltaY); let newTarget = clamp(camera.targetScale * zoomFactor, allowedScales[0], allowedScales[allowedScales.length-1]);
    const rect = canvas.getBoundingClientRect(); const sx = e.clientX - rect.left, sy = e.clientY - rect.top;
    const worldBeforeX = camera.x + sx / camera.targetScale; const worldBeforeY = camera.y + sy / camera.targetScale;
    camera.targetScale = newTarget;
    const worldAfterX = camera.x + sx / camera.targetScale; const worldAfterY = camera.y + sy / camera.targetScale;
    camera.x += (worldAfterX - worldBeforeX); camera.y += (worldAfterY - worldBeforeY);
    scheduleSnap();
  }, {passive:true});
  canvas.addEventListener('dblclick', () => { camera.targetScale = 1.0; });

  // particles
  const particles = [];
  function spawnFootParticles(){ const footX = player.x + (player.facing === 1 ? player.w*0.18 : -player.w*0.18); const footY = player.y + player.h/2 - 4; const count = Math.random() < 0.5 ? 1 : 2; for(let i=0;i<count;i++){ particles.push({ x: footX + (Math.random()-0.5)*8, y: footY + (Math.random()-0.5)*4, vx: (Math.random()-0.5)*80 + player.vx*0.15, vy: -Math.random()*120 - 20, life: 0.45 + Math.random()*0.25, age: 0, size: 2 + Math.random()*2 }); if(particles.length > 300) particles.shift(); } }

  // clouds
  function makeClouds(){
    clouds = [];
    for(let i=0;i<Math.max(12, Math.floor(WORLD_W/16));i++){
      clouds.push({ x: Math.random() * WORLD_W * TILE, y: 40 + Math.random()*160, scale: 0.6 + Math.random()*1.2, speed: 6 + Math.random()*18, alpha: 0.6 + Math.random()*0.35 });
    }
  }

  // movement helper
  function moveToward(v, target, maxDelta){ if(v < target) return Math.min(v + maxDelta, target); if(v > target) return Math.max(v - maxDelta, target); return v; }

  // game loop variables
  let last = performance.now(); let acc = 0; const STEP = 1/60; window.dt = STEP; let frames = 0, fps = 0, fpsTimer = 0; let footParticleCooldown = 0;
  let gameStarted = false;

  function physicsStep(){
    let target = 0; if(input.left) target -= MAX_SPEED; if(input.right) target += MAX_SPEED; const accel = player.onGround ? GROUND_ACCEL : AIR_ACCEL; player.vx = moveToward(player.vx, target, accel * STEP);
    player.vy += GRAVITY * STEP; if(player.vy > MAX_FALL) player.vy = MAX_FALL;
    coyoteTimer -= STEP; if(player.onGround) coyoteTimer = COYOTE_TIME; if(jumpBufferTimer > 0) jumpBufferTimer -= STEP;
    if(jumpBufferTimer > 0 && coyoteTimer > 0){ player.vy = -JUMP_SPEED; player.onGround = false; coyoteTimer = 0; jumpBufferTimer = 0; }
    if(!input.jumpHeld && player.vy < 0){ if(player.vy < -JUMP_CUTOFF) player.vy = -JUMP_CUTOFF; }
    footParticleCooldown -= STEP; if(player.onGround && Math.abs(player.vx) > 40){ if(footParticleCooldown <= 0){ spawnFootParticles(); footParticleCooldown = 0.06; } }
    for(let i=particles.length-1;i>=0;i--){ const p = particles[i]; p.vy += GRAVITY * 0.5 * STEP; p.x += p.vx * STEP; p.y += p.vy * STEP; p.age += STEP; if(p.age >= p.life) particles.splice(i,1); }
    const res = resolveCollision(player.x, player.y, player.w, player.h, player.vx, player.vy, STEP);
    player.x = res.x; player.y = res.y; player.vx = res.vx; player.vy = res.vy; player.onGround = res.onGround; if(player.vx < -1) player.facing = -1; if(player.vx > 1) player.facing = 1;
  }

  // sky helpers
  function lerp(a,b,t){ return a + (b-a)*t; }
  function lerpColor(c1, c2, t){ return `rgb(${Math.round(lerp(c1[0],c2[0],t))},${Math.round(lerp(c1[1],c2[1],t))},${Math.round(lerp(c1[2],c2[2],t))})`; }

  function drawSky(){
    const t = clamp(player.x / (WORLD_W * TILE), 0, 1);
    const topColor = t < 0.5 ? lerpColor([120,190,255],[90,160,255], t*2) : lerpColor([90,160,255],[20,40,90], (t-0.5)*2);
    const bottomColor = t < 0.5 ? lerpColor([200,230,255],[140,205,255], t*2) : lerpColor([140,205,255],[60,90,140], (t-0.5)*2);
    const g = ctx.createLinearGradient(0,0,0,canvas.height);
    g.addColorStop(0, topColor); g.addColorStop(1, bottomColor);
    ctx.fillStyle = g; ctx.fillRect(0,0,canvas.width,canvas.height);

    const sunX = (t * 1.1 - 0.05) * canvas.width;
    const sunArc = Math.sin(t * Math.PI);
    const sunY = canvas.height * 0.18 - sunArc * (canvas.height * 0.12);
    const sunRadius = 36 + sunArc * 14;
    const sunGrad = ctx.createRadialGradient(sunX, sunY, 0, sunX, sunY, sunRadius*4);
    sunGrad.addColorStop(0, 'rgba(255,245,200,0.9)');
    sunGrad.addColorStop(0.2, 'rgba(255,220,120,0.35)');
    sunGrad.addColorStop(1, 'rgba(255,200,120,0)');
    ctx.fillStyle = sunGrad; ctx.beginPath(); ctx.arc(sunX, sunY, sunRadius*4, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = 'rgba(255,248,210,1)'; ctx.beginPath(); ctx.arc(sunX, sunY, sunRadius, 0, Math.PI*2); ctx.fill();

    for(const c of clouds){
      const parallax = 0.35 + 0.45 * (1 - c.scale);
      const cx = ((c.x - camera.x * parallax) % (WORLD_W * TILE + 800)) - 400;
      const cy = c.y + Math.sin((c.x + performance.now()*0.0002*c.speed) * 0.001) * 6;
      ctx.globalAlpha = c.alpha * 0.95;
      drawCloud(cx, cy, c.scale);
      ctx.globalAlpha = 1;
    }
  }
  function drawCloud(x,y,s){ ctx.save(); ctx.translate(x,y); ctx.scale(s,s); ctx.fillStyle = 'rgba(255,255,255,0.92)'; ctx.beginPath(); ctx.ellipse(0,0,46,22,0,0,Math.PI*2); ctx.ellipse(-34,4,28,16,0,0,Math.PI*2); ctx.ellipse(34,4,28,16,0,0,Math.PI*2); ctx.fill(); ctx.restore(); }

  function draw(){
    ctx.save(); ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
    drawSky(); ctx.restore();

    ctx.save(); ctx.imageSmoothingEnabled = false; ctx.scale(camera.scale, camera.scale); ctx.translate(-Math.floor(camera.x), -Math.floor(camera.y));

    const viewW = canvas.width / camera.scale; const viewH = canvas.height / camera.scale;
    const startX = Math.floor(camera.x / TILE) - 1; const endX = Math.ceil((camera.x + viewW) / TILE) + 1;
    const startY = Math.floor(camera.y / TILE) - 1; const endY = Math.ceil((camera.y + viewH) / TILE) + 1;
    for(let tx = startX; tx <= endX; tx++){
      for(let ty = startY; ty <= endY; ty++){
        if(tx<0||tx>=WORLD_W||ty<0||ty>=WORLD_H) continue;
        const t = tileAt(tx,ty); if(!t) continue;
        let isTop = false; if(!tileAt(tx, ty-1)) isTop = true; const px = tx * TILE; const py = ty * TILE;
        ctx.fillStyle = '#6B3E1E'; ctx.fillRect(px, py, TILE, TILE);
        if(isTop){ ctx.fillStyle = '#2CA02C'; ctx.fillRect(px, py, TILE, Math.floor(TILE*0.28)); }
        ctx.strokeStyle = 'rgba(0,0,0,0.12)'; ctx.strokeRect(px+0.5, py+0.5, TILE-1, TILE-1);
      }
    }

    for(const p of particles){ const alpha = 1 - (p.age / p.life); ctx.globalAlpha = Math.max(0, alpha); ctx.fillStyle = '#d9c6a6'; const sx = Math.round(p.x - p.size/2), sy = Math.round(p.y - p.size/2); ctx.fillRect(sx, sy, Math.max(1, Math.round(p.size)), Math.max(1, Math.round(p.size))); }
    ctx.globalAlpha = 1;

    const px = Math.floor(player.x - player.w/2); const py = Math.floor(player.y - player.h/2);
    ctx.fillStyle = '#fefefe'; ctx.fillRect(px, py, player.w, player.h);
    ctx.fillStyle = '#0066cc'; ctx.fillRect(px+3, py+8, player.w-6, player.h-10);
    ctx.fillStyle = '#000'; ctx.fillRect(px + (player.facing===1 ? player.w-7 : 4), py+8, 3, 3);
    ctx.strokeStyle = 'rgba(0,0,0,0.6)'; ctx.strokeRect(px, py, player.w, player.h);

    ctx.restore();

    hud.innerHTML = `x:${Math.round(player.x)} y:${Math.round(player.y)} vx:${Math.round(player.vx)} vy:${Math.round(player.vy)} fps:${Math.round(fps)} zoom:${camera.scale.toFixed(2)}`;
  }

  function updateCamera(){
    const targetX = player.x - (canvas.width / (2 * camera.scale)); const targetY = player.y - (canvas.height / (2 * camera.scale));
    camera.x += (targetX - camera.x) * 0.12; camera.y += (targetY - camera.y) * 0.12; camera.scale += (camera.targetScale - camera.scale) * 0.12;
    if(Math.abs(camera.scale - camera.targetScale) < 0.001) camera.scale = camera.targetScale;
    camera.x = clamp(camera.x, 0, Math.max(0, WORLD_W * TILE - canvas.width / camera.scale)); camera.y = clamp(camera.y, 0, Math.max(0, WORLD_H * TILE - canvas.height / camera.scale));
  }

  // progressive terrain generation using seeded RNG
  async function generateTerrain(seedString, rng){
    // reallocate arrays based on WORLD_W/WORLD_H
    tiles = new Uint8Array(WORLD_W * WORLD_H);
    heightMap = new Array(WORLD_W);

    // reset clouds and particles for new world
    particles.length = 0;
    makeClouds();

    // show loader
    loading.style.display = 'flex';
    loaderFill.style.width = '0%'; loaderText.textContent = '0%';

    const seeds = 8; const seedVals = [];
    for(let i=0;i<seeds;i++) seedVals.push(rng()*6 - 3);

    for(let x=0;x<WORLD_W;x++){
      let v = 0;
      v += Math.sin(x*0.02) * 3.5;
      v += Math.sin(x*0.005)*8.0;
      v += Math.sin(x*0.11)*1.5;
      const t = (x/WORLD_W)*(seeds-1);
      const i0 = Math.floor(t), f = t - i0;
      const a = seedVals[i0 % seeds]; const b = seedVals[(i0+1) % seeds];
      v += (a*(1-f) + b*f) * 3.0;
      let h = Math.floor(WORLD_H*0.5 + v);
      if(h > WORLD_H-2) h = WORLD_H-2;
      if(h < 6) h = 6;
      heightMap[x] = h;
      for(let y=h; y<WORLD_H; y++) tiles[y*WORLD_W + x] = 1;

      if(x % 6 === 0){
        const pct = Math.round((x / (WORLD_W-1)) * 100);
        loaderFill.style.width = pct + '%'; loaderText.textContent = pct + '%';
        await new Promise(r => setTimeout(r, 0));
      }
    }

    // floating platforms
    for(let i=0;i<Math.floor(WORLD_W/5);i++){
      const px = Math.floor(rng() * (WORLD_W-8));
      const py = Math.floor(rng() * (WORLD_H/2)) + 6;
      const len = Math.floor(rng()*5) + 2;
      for(let x=px; x<px+len; x++) tiles[py*WORLD_W + x] = 1;
    }

    loaderFill.style.width = '100%'; loaderText.textContent = '100%';
    // small fade & hide
    loading.style.transition = 'opacity 360ms ease';
    loading.style.opacity = '0';
    await new Promise(r => setTimeout(r, 420));
    loading.style.display = 'none';
    loading.style.opacity = '1';
  }

  // main loop operations
  function frame(now){
    const dt_real = (now - last) / 1000; last = now;
    acc += dt_real; if(acc > 0.25) acc = 0.25;
    while(acc >= STEP){ physicsStep(); acc -= STEP; }
    updateCamera(); draw();
    frames++; fpsTimer += dt_real;
    if(fpsTimer >= 0.5){ fps = frames / fpsTimer; frames = 0; fpsTimer = 0; }
    requestAnimationFrame(frame);
  }

  // focus canvas on click
  canvas.tabIndex = 1000; canvas.style.outline = 'none'; canvas.addEventListener('click', () => canvas.focus());

  // ---------- UI logic (menu) ----------
  const menu = document.getElementById('mainMenu');
  const seedInput = document.getElementById('seedInput');
  const randomSeedBtn = document.getElementById('randomSeedBtn');
  const startBtn = document.getElementById('startBtn');
  const editorBtn = document.getElementById('editorBtn');
  const seedPreview = document.getElementById('seedPreview');
  const widthRange = document.getElementById('widthRange');
  const heightRange = document.getElementById('heightRange');
  const widthVal = document.getElementById('widthVal');
  const heightVal = document.getElementById('heightVal');
  const startZoom = document.getElementById('startZoom');

  widthRange.addEventListener('input', ()=>{ widthVal.textContent = widthRange.value; });
  heightRange.addEventListener('input', ()=>{ heightVal.textContent = heightRange.value; });

  function previewSeedHash(s){
    const h = xfnv1a(String(s || ''));
    seedPreview.textContent = h.toString(16).padStart(8,'0').toUpperCase();
  }
  seedInput.addEventListener('input', ()=> previewSeedHash(seedInput.value));
  previewSeedHash('');

  function makeRandomSeed(){
    const adjectives = ["Misty","Silent","Neon","Crimson","Lone","Windy","Broken","Shy","Solar","Blue"];
    const nouns = ["Island","Valley","Hollow","Plateau","Grove","Dunes","Isle","Cavern","Reach","Shore"];
    return adjectives[Math.floor(Math.random()*adjectives.length)] + nouns[Math.floor(Math.random()*nouns.length)] + Math.floor(Math.random()*999);
  }

  randomSeedBtn.addEventListener('click', ()=>{
    const s = makeRandomSeed();
    seedInput.value = s;
    previewSeedHash(s);
  });

  // core: start the game with chosen seed and sizes
  async function startGame(fromMenu=true){
    // read UI
    const seedStr = seedInput.value.trim() || (makeRandomSeed());
    previewSeedHash(seedStr);
    WORLD_W = parseInt(widthRange.value, 10) || 300;
    WORLD_H = parseInt(heightRange.value, 10) || 40;
    camera.targetScale = Number(startZoom.value) || 1;
    camera.scale = camera.targetScale;

    // prepare RNG
    const seedNum = xfnv1a(seedStr);
    const rng = mulberry32(seedNum);

    // reset player and camera
    player.x = TILE*5 + TILE/2; player.vx = 0; player.vy = 0; player.onGround = false;
    camera.x = 0; camera.y = 0;

    hud.innerHTML = 'Generating world...';
    await generateTerrain(seedStr, rng);

    // place player at spawn column if available
    const spawnX = 5;
    player.x = spawnX * TILE + TILE/2;
    player.y = (heightMap[Math.min(spawnX, heightMap.length-1)] - 2) * TILE;
    // ensure camera starts near player
    camera.x = player.x - (canvas.width / (2 * camera.scale));
    camera.y = player.y - (canvas.height / (2 * camera.scale));

    hud.innerHTML = 'World ready — have fun!';

    if(fromMenu){
      // hide menu on first start
      menu.style.display = 'none';
    }

    // start frame loop once
    if(!gameStarted){
      last = performance.now();
      gameStarted = true;
      requestAnimationFrame(frame);
    }
  }

  // Quick regen: regenerate with current UI values while in-game (shows loader)
  editorBtn.addEventListener('click', ()=> {
    startGame(false).catch(err => { console.error(err); });
  });

  startBtn.addEventListener('click', ()=>{
    startGame(true).catch(err => { console.error(err); });
  });

  // auto-fill seed with a random one for convenience
  seedInput.value = makeRandomSeed();
  previewSeedHash(seedInput.value);

  // keep initial HUD
  hud.innerHTML = 'Open menu to create a world.';
})();
</script>
</body>
</html>
